# xx.xxxxxx

## 参考思路 - 贪心

**这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！**

**贪心算法局部最优解：每次取最大跳跃步数，更新最大覆盖范围**

**整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。

![55.跳跃游戏](https://img-blog.csdnimg.cn/20201124154758229.png)

- 时间复杂度：O(n)
- 空间复杂度：O(1)

## 参考代码

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        if (nums.size() == 1) return true; // 只有一个元素，就是能达到
        for (int i = 0; i <= cover; i++) { // 注意这里是小于等于cover
            cover = max(i + nums[i], cover);
            if (cover >= nums.size() - 1) return true; // 说明可以覆盖到终点了
        }
        return false;
    }
};
```



## 我的思路 - 贪心



- 时间复杂度：O(n)
- 空间复杂度：O(1)

## 我的代码

```
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int zero = -1;
        for(int i=nums.size()-2; i>=0;i--)
        {
            if(zero==-1 && nums[i]==0)
            {
                zero=i;
            }
            if(zero!=-1 && nums[i]>zero-i)
            {
                zero=-1;
            }
        }
    if(zero==-1)  return true;
    return false;
    }
};
```

