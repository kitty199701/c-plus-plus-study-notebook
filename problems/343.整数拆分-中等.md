# 343.整数拆分-中等

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。



## 参考思路 - 贪心

正整数4可以拆分成2+2，乘积不变（4=2×2）。对于大于 4 的正整数，总是存在一种拆分的方案，使得拆分成的两个正整数的乘积大于拆分前的正整数（例如，5=2+3，2×3=6>5）。

**归纳证明法**

1. 第一步：证明最优的拆分方案中不会出现大于4的整数。

   假设出现了大于等于4的整数x，由于2(x-2)>=x在 x>=4时恒成立，将x拆分成2和x−2可以增大乘积。因此最优的拆分方案中不会出现大于等于4的整数。

   此时，我们可以知道，最优的拆分方案中只会出现 1，2和3

2. 第二步：证明当n>=5时，最优的拆分方案中不会出现整数1。

   当n>=5时，如果出现了整数1，那么拆分中剩余的数的和为n-1≥4，对应至少两个整数。我们将其中任意一个整数x加上1，乘积就会增大。因此最优的拆分方案中不会出现整数1。

3. 第三步：证明当n>=5时，最优的拆分方案中2的个数最多2个。


如果出现了3个2，那么将它们转换成2个3，可以增大乘积，即3 * 3 > 2 * 2 * 2。

**因此我们可以对n除以3的三种余数情况进行分析**

- 余数为0时，拆分成3 * 3 * ... *3

- 余数为1时，拆分成3 * 3 * ... *4

- 余数为2时，拆分成3 * 3 * ... *2

  

- 时间复杂度：O(1)
- 空间复杂度：O(1)

## 参考代码

```c++
#include<math.h>
class Solution {
public:
    int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        if (n % 3 == 0)  return pow(3, n / 3);
        if (n % 3 == 1)  return pow(3, (n / 3) - 1) * 4;
        if (n % 3 == 2)  return pow(3, n / 3) * 2;
        return 0;
    }
};
```



## 我的思路 - 动态规划

对于的正整数 n，当 n>=2 时，可以拆分成至少两个正整数的和。令j为拆分出的第一个正整数，则剩下的部分是 n-j，n-j可以不继续拆分，或者继续拆分成至少两个正整数的和。**由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。**

创建数组dp，其dp[i]表示将正整数i拆分成至少两个正整数的和之后，这些正整数的最大乘积。特别地，1 是最小的正整数，1 不能拆分，因此dp[1]=0。

当拆分出来的第一个正整数j固定时，转移方程为
`dp[i] = max(dp[j],j) * max(dp[i-j],i-j)`

由于j的取值范围是 1 到i/2，需要遍历所有的j得到dp[i] 的最大值

```c++
curmax= max(dp[j],j) * max(dp[i-j],i-j)；
dp[i] = max(dp[i], curmax);
```


- 时间复杂度：O(n^2)
- 空间复杂度：O(n)

## 我的代码

```c++
class Solution {
public:
    int integerBreak(int n) {
        int dp[60]={0};
        dp[1] = 0;
        dp[2] = 1;
        for (int i = 3; i <= n; i++)
        {
            for(int j = 1; j <= i/2; j++)
            {
                int curmax = max(dp[j],j) * max(dp[i-j],i-j);
                dp[i] = max(dp[i], curmax);
            }
        }
        return dp[n];
    }
};
```

